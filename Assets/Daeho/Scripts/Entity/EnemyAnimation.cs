using System.Collections;
using System.Collections.Generic;
using UnityEngine;

using SB = System.SerializableAttribute;


public class EnemyAnimation : MonoBehaviour
{
    #region Animation states
    public abstract class AnimState
    {
        [Tooltip("애니메이션 프레임")]
        public Sprite[] frame_sprites;
        public System.Action[] frames_actions;
        [Tooltip("애니메이션 딜레이")]
        public float[] delay;
        [Tooltip("애니메이션 반복")]
        public bool loop;
        [Tooltip("대기 후 애니메이션이 끝난 후 마지막 프레임 실행")]
        public bool wait;
        [Tooltip("대기할 인덱스")]
        public int wait_index_start;
        public int wait_index_end;

        public System.Action OnAnimationEnd = null;

        protected Enemy model;

        internal int index = 0;

        internal bool anim_end = false;

        public Coroutine update { get; set; } = null;

        public void SetModel(Enemy model)
        {
            index = 0;
            frames_actions = new System.Action[frame_sprites.Length];

            if (this.model != null) return;

            this.model = model;
        }

        /// <summary>
        /// 애니메이션 진행
        /// </summary>
        /// <returns></returns>
        public virtual IEnumerator Update()
        {
            yield return null;

            if (delay.Length != frame_sprites.Length)
            {
                if (delay.Length > 0) Debug.Log("Delay array initializing");

                delay = new float[frame_sprites.Length];
            }

            for (int i = 0; i < delay.Length; i++)
            {
                if (delay[i] == 0)
                    delay[i] = 0.01f;
            }

            // 애니메이션 프레임이 없을 경우 종료
            if (frame_sprites == null || frame_sprites.Length == 0)
                yield break;

            anim_end = wait;

            while (true)
            {
                // 마지막 애니메이션 프레임에 도달했을 경우
                if (index >= frame_sprites.Length)
                {
                    if (loop == false)
                    {
                        OnAnimationEnd?.Invoke();
                        yield break;
                    }
                    else index = 0;
                }
                // 실행이 끝날 때까지 대기
                else if (anim_end && index > wait_index_end)
                {
                    index = wait_index_start;
                }

                model.renderer.sprite = frame_sprites[index];

                frames_actions[index]?.Invoke();
                frames_actions[index] = null;

                yield return new WaitForSeconds(delay[index]);

                index++;
            }
        }

        /// <summary>
        /// 애니메이션의 현재 index 대기 시간을 반환하는 함수
        /// </summary>
        /// <returns></returns>
        public float GetDelay()
        {
            return delay[index];
        }
    }

    // 기본 상태
    [SB]
    public class IdleState : AnimState
    {
    }

    // 움직임 상태
    [SB]
    public class WalkState : AnimState
    {
    }

    // 공격 상태
    [SB]
    public class AttackState : AnimState
    {
    }

    #region 공격 패턴이 여러개일 때
    [SB]
    public class Attack1State : AnimState
    {
    }

    [SB]
    public class Attack2State : AnimState
    {
    }

    [SB]
    public class Attack3State : AnimState
    {
    }

    [SB]
    public class Attack4State : AnimState
    {
    }

    [SB]
    public class Attack5State : AnimState
    {
    }
    #endregion

    // 피격 상태
    [SB]
    public class HitState : AnimState
    {
    }

    // 죽음 상태
    [SB]
    public class DeadState : AnimState
    {
    }
    #endregion

    private Enemy _model;
    Enemy model
    {
        get
        {
            if (_model == null)
            {
                _model = GetComponent<Enemy>();
            }

            return _model;
        }
    }

    [Space(10)]
    [SerializeField] IdleState idle;
    [Space(10)]
    [SerializeField] WalkState walk;
    [Space(10)]
    [SerializeField] AttackState attack;
    #region 공격 패턴이 여러개일 때
    [Space(10)]
    [SerializeField] Attack1State attack1;
    [Space(10)]
    [SerializeField] Attack2State attack2;
    [Space(10)]
    [SerializeField] Attack3State attack3;
    [Space(10)]
    [SerializeField] Attack4State attack4;
    [Space(10)]
    [SerializeField] Attack5State attack5;
    #endregion
    [Space(10)]
    [SerializeField] HitState hit;
    [Space(10)]
    [SerializeField] DeadState dead;

    private AnimState _state;
    protected AnimState state
    {
        get => _state;
        set
        {
            // 이전 애니메이션이 진행 중이라면 중단
            if (_state != null && _state.update != null)
            {
                StopCoroutine(_state.update);
            }

            _state = value;
            _state.SetModel(model);
        }
    }

    string s_state = "";

    void Start()
    {
    }

    /// <summary>
    /// Animation 현재 State 변경 함수
    /// </summary>
    /// <param name="name">변경할 State 이름</param>
    public void SetState(string name)
    {
        switch (name)
        {
            case string n when nameof(IdleState).Contains(n):
                state = idle;
                break;
            case string n when nameof(WalkState).Contains(n):
                state = walk;
                break;
            case string n when nameof(HitState).Contains(n):
                state = hit;
                break;
            case string n when nameof(AttackState).Contains(n):
                state = attack;
                break;
            #region 공격 패턴이 여러개일 때
            case string n when nameof(Attack1State).Contains(n):
                state = attack1;
                break;
            case string n when nameof(Attack2State).Contains(n):
                state = attack2;
                break;
            case string n when nameof(Attack3State).Contains(n):
                state = attack3;
                break;
            case string n when nameof(Attack4State).Contains(n):
                state = attack4;
                break;
            case string n when nameof(Attack5State).Contains(n):
                state = attack5;
                break;
            #endregion
            case string n when nameof(DeadState).Contains(n):
                state = dead;
                break;
            default:
                Debug.Assert(false);
                return;
        }

        s_state = name;
        state.update = StartCoroutine(state.Update());
    }

    /// <summary>
    /// wait이 true로 설정되었을 경우 호출 가능, 패턴 실행이 종료되었음을 통지하는 함수
    /// </summary>
    /// <returns></returns>
    public void AnimEnd()
    {
        if (state.wait == false) return;

        state.anim_end = false;
    }

    /// <summary>
    /// 현재 Animation State를 받아오는 함수
    /// - Idle
    /// - Walk
    /// - Hit
    /// - Attack
    /// - Dead
    /// </summary>
    /// <returns></returns>
    public string GetStateName()
    {
        return s_state;
    }

    /// <summary>
    /// 현재 Animation State 이름을 받아오는 함수
    /// - Idle
    /// - Walk
    /// - Hit
    /// - Attack
    /// - Dead
    /// </summary>
    /// <returns></returns>
    public AnimState GetState()
    {
        return state;
    }
}
